
# ‚úÖ Step 1: Combined Guard + Logger Wrapper

Create a file:

## **File:** `utils/agentSafety.js`

This will include:

* Input guard
* Output guard
* Safe wrapper
* Logging integration

```js
// -------------------------------------------------------------
// agentSafety.js
// Combined input guard, output guard, logging, and safe wrapper
// -------------------------------------------------------------

import { logStart, logEnd, logInfo, logError } from "./logger.js";

// 1) Input Guard
export function validateUserInput(input) {
  if (typeof input !== "string") {
    throw new Error("User message must be a string.");
  }

  if (input.trim().length === 0) {
    throw new Error("Empty message not allowed.");
  }

  if (input.length > 800) {
    throw new Error("Message too long. Limit to 800 characters.");
  }

  // Basic protection against prompt injection
  const banned = ["ignore previous", "sudo", "rm -rf", "<script>"];
  for (let b of banned) {
    if (input.toLowerCase().includes(b)) {
      throw new Error("Unsafe or restricted content detected.");
    }
  }

  return input;
}

// 2) Output Guard using Zod schema
export function validateModelOutput(schema, rawText) {
  try {
    const json = JSON.parse(rawText);
    return schema.parse(json);
  } catch (err) {
    logError("Output validation failed", rawText);
    throw new Error("Model returned invalid JSON or schema mismatch.");
  }
}

// 3) Combined Safe Agent Turn Wrapper
export async function safeAgentTurn({
  chat,
  userMessage,
  schema,
  tools,
  config
}) {
  logStart("Agent Turn");

  // Step A: Validate input
  let cleanedInput;
  try {
    cleanedInput = validateUserInput(userMessage);
    logInfo("Validated User Input", cleanedInput);
  } catch (err) {
    logError("Input Validation Error", err.message);
    throw err;
  }

  // Step B: Call model
  let response;
  const start = Date.now();

  try {
    response = await chat.sendMessage({
      message: cleanedInput,
      tools,
      config
    });

    const end = Date.now();
    logInfo("Model Latency (ms)", end - start);
    logInfo("Raw Model Response", response.text);

  } catch (err) {
    logError("Model Call Failed", err);
    throw err;
  }

  // Step C: Validate output using schema
  let parsed;
  try {
    parsed = validateModelOutput(schema, response.text);
    logInfo("Validated Output", parsed);
  } catch (err) {
    logError("Output Validation Error", err.message);
    throw err;
  }

  logEnd("Agent Turn");
  return parsed;
}
```

---

# ‚úÖ Step 2: Use This Wrapper in Your Full Agent

Now update `09.full-agent.js` to use **safeAgentTurn**.

## **Replace your runAgentTurn()** with this:

```js
import { safeAgentTurn } from "../utils/agentSafety.js";

async function runAgentTurn(chat, userMessage) {
  return await safeAgentTurn({
    chat,
    userMessage,
    schema: agentResponseSchema,
    tools,
    config: {
      systemInstruction: SYSTEM_INSTRUCTION,
      temperature: 0.2,
      thinkingConfig: { thinkingBudget: 0 },
      responseMimeType: "application/json",
      responseJsonSchema: zodToJsonSchema(agentResponseSchema)
    }
  });
}
```

This removes:

* manual Zod parsing
* manual try/catch
* manual logging
* manual input validation
* manual latency tracking

Everything is handled in one place.

---

# üîç What Your Safe Wrapper Now Handles Automatically

| Step                            | Done automatically | Inside              |
| ------------------------------- | ------------------ | ------------------- |
| Validate user input             | Yes                | input guard         |
| Log input                       | Yes                | logInfo             |
| Call chat + tools               | Yes                | inside safe wrapper |
| Track latency                   | Yes                | Date.now()          |
| Log raw JSON                    | Yes                | logInfo             |
| Validate JSON schema            | Yes                | Zod                 |
| Log validated output            | Yes                | logInfo             |
| Catch & log errors              | Yes                | logError            |
| Return only clean parsed result | Yes                | safe wrapper        |

Your `09.full-agent.js` becomes *much cleaner*.

---

# Example Final Output (Clean & Safe)

Terminal will show:

```
=== START: Agent Turn ===
[INFO] Validated User Input: "Compute 23 * 76"
[INFO] Model Latency (ms): 154
[INFO] Raw Model Response:
"{ "answer": "23 * 76 = 1748", "data": { ... } }"
[INFO] Validated Output: { answer: "1748", used_tools: ["calculate"], data: { ... } }
=== END: Agent Turn ===
```

Then your app receives **safe parsed JSON**:

```json
{
  "answer": "1748",
  "used_tools": ["calculate"],
  "data": { "result": 1748 }
}
```

---