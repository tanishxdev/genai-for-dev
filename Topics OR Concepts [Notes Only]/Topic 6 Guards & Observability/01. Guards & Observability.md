
# **Topic 6: Guards & Observability (Agent Safety + Reliability Layer)**

This is a MUST for **real-world, production agents**.

---

# **Topic 6 ‚Äî Guards, Validation & Observability in Gemini Agents**

---

## **1. Goal**

Agents must be:

* **Safe** (inputs validated)
* **Predictable** (outputs validated with schema)
* **Traceable** (logs & errors easy to debug)
* **Reliable** (no silent failures)

This topic teaches:

* Input Guards
* Output Guards
* Schema Validation
* Logging (observability)
* Error Handling (try/catch wrappers)

---

# **2. What Are Guards?**

## **Input Guards**

Before sending prompt ‚Üí Validate user input
Example:

* Limit length
* Only allow valid GitHub usernames
* Prevent injections like ‚Äúignore previous instructions‚Äù

## **Output Guards**

After model returns ‚Üí Check that output:

* matches schema
* has no null fields where required
* is not hallucinated
* is safe to process

**In Gemini SDK, we use Zod for this.**

---

# **3. Code: Create a Guarded Agent Wrapper**

We‚Äôll build a reusable module you can apply on ANY agent script.

## **File:** `utils/agentGuard.js`

```js
// -------------------------------------------------------------
// agentGuard.js
// A reusable safety + validation layer for Gemini outputs
// -------------------------------------------------------------
import { z } from "zod";

// Basic utility guard for user input
export function validateUserInput(input) {
  if (typeof input !== "string") throw new Error("Input must be a string.");

  if (input.length > 500) {
    throw new Error("Input too long. Limit to 500 characters.");
  }

  if (input.includes("<script>") || input.includes("rm -rf")) {
    throw new Error("Unsafe input detected.");
  }

  return input;
}

// Generic output guard
export function validateOutput(schema, responseText) {
  try {
    const json = JSON.parse(responseText);
    return schema.parse(json);
  } catch (e) {
    console.error("Output validation failed:", e.message);
    throw new Error("Model returned invalid or unsafe JSON.");
  }
}
```

---

# **4. Implement Guarded Agent Call**

## **File:** `src/10.guarded-agent.js`

```js
// -------------------------------------------------------------
// GOAL: Add input & output guards to your agent
// -------------------------------------------------------------

import ai from "../utils/geminiClient.js";
import { validateUserInput, validateOutput } from "../utils/agentGuard.js";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

// 1) Output schema (strict)
const guardedSchema = z.object({
  answer: z.string(),
  info: z.object({}).optional()
});

// 2) System rules
const SYSTEM = `
You are a factual agent.
Never output anything except JSON matching the required schema.
`;

// 3) Guarded agent function
async function guardedAgent(userMessage) {
  // Validate input
  const cleaned = validateUserInput(userMessage);

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: cleaned,
    config: {
      systemInstruction: SYSTEM,
      responseMimeType: "application/json",
      responseJsonSchema: zodToJsonSchema(guardedSchema)
    }
  });

  // Validate output JSON
  return validateOutput(guardedSchema, response.text);
}

// Demo run
async function main() {
  const result = await guardedAgent("Explain AI in one line.");
  console.log("Validated Output:\n", result);
}

await main();
```

---

# **5. Output Example**

```
Validated Output:
{
  answer: "AI is a field of computer science that enables machines to learn and make decisions.",
  info: {}
}
```

Fully validated JSON, safe to use everywhere.

---

# **6. Why This Is Important**

Without guards:

* Agent can hallucinate fields
* JSON may break your application
* A user can crash the model with bad input
* Your tools can be invoked incorrectly

With guards:

* Predictable
* Safe
* Developer-friendly
* Production-ready

---

# **7. Notes for your Topics folder**

Create:

```
üìÅTopic 6 Guards & Observability
 ‚îú‚îÄ‚îÄ 01.guards-input-output.md
```

Content:

```
# Topic 6 ‚Äî Guards, Validation & Observability

Input Guards:
- Validate user input before sending to model
- Avoid unsafe or malicious strings
- Limit length and enforce format

Output Guards:
- Validate model JSON using Zod
- Prevent hallucinated fields
- Enforce strict schema

Observability:
- Log tokens, tool calls, latency
- Use console/debug logs during development
- In production use logging systems (pino/winston)

Purpose:
Ensure agent reliability, safety, and predictability.
```

---Perfect ‚Äî we‚Äôll **keep the exact setup style** you prefer (clean JS, reusable `geminiClient.js`, short main function).
Now we continue with the **next topic in your structured learning path**.

You have completed up to:

* Topic 1 ‚Üí Intro
* Topic 2 ‚Üí Model Parameters
* Topic 2.1 ‚Üí Advanced Config
* Topic 2.2 ‚Üí Structured Outputs
* Topic 2.3 ‚Üí Streaming
* Topic 3 ‚Üí Multi-Turn Chat
* Topic 4 ‚Üí Tool Calling
* Topic 5 ‚Üí Full Agent

The next major foundational topic is:

# **Topic 6: Guards & Observability (Agent Safety + Reliability Layer)**

This is a MUST for **real-world, production agents**.

---

# **Topic 6 ‚Äî Guards, Validation & Observability in Gemini Agents**

---

## **1. Goal**

Agents must be:

* **Safe** (inputs validated)
* **Predictable** (outputs validated with schema)
* **Traceable** (logs & errors easy to debug)
* **Reliable** (no silent failures)

This topic teaches:

* Input Guards
* Output Guards
* Schema Validation
* Logging (observability)
* Error Handling (try/catch wrappers)

---

# **2. What Are Guards?**

## **Input Guards**

Before sending prompt ‚Üí Validate user input
Example:

* Limit length
* Only allow valid GitHub usernames
* Prevent injections like ‚Äúignore previous instructions‚Äù

## **Output Guards**

After model returns ‚Üí Check that output:

* matches schema
* has no null fields where required
* is not hallucinated
* is safe to process

**In Gemini SDK, we use Zod for this.**

---

# **3. Code: Create a Guarded Agent Wrapper**

We‚Äôll build a reusable module you can apply on ANY agent script.

## **File:** `utils/agentGuard.js`

```js
// -------------------------------------------------------------
// agentGuard.js
// A reusable safety + validation layer for Gemini outputs
// -------------------------------------------------------------
import { z } from "zod";

// Basic utility guard for user input
export function validateUserInput(input) {
  if (typeof input !== "string") throw new Error("Input must be a string.");

  if (input.length > 500) {
    throw new Error("Input too long. Limit to 500 characters.");
  }

  if (input.includes("<script>") || input.includes("rm -rf")) {
    throw new Error("Unsafe input detected.");
  }

  return input;
}

// Generic output guard
export function validateOutput(schema, responseText) {
  try {
    const json = JSON.parse(responseText);
    return schema.parse(json);
  } catch (e) {
    console.error("Output validation failed:", e.message);
    throw new Error("Model returned invalid or unsafe JSON.");
  }
}
```

---

# **4. Implement Guarded Agent Call**

## **File:** `src/10.guarded-agent.js`

```js
// -------------------------------------------------------------
// GOAL: Add input & output guards to your agent
// -------------------------------------------------------------

import ai from "../utils/geminiClient.js";
import { validateUserInput, validateOutput } from "../utils/agentGuard.js";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

// 1) Output schema (strict)
const guardedSchema = z.object({
  answer: z.string(),
  info: z.object({}).optional()
});

// 2) System rules
const SYSTEM = `
You are a factual agent.
Never output anything except JSON matching the required schema.
`;

// 3) Guarded agent function
async function guardedAgent(userMessage) {
  // Validate input
  const cleaned = validateUserInput(userMessage);

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: cleaned,
    config: {
      systemInstruction: SYSTEM,
      responseMimeType: "application/json",
      responseJsonSchema: zodToJsonSchema(guardedSchema)
    }
  });

  // Validate output JSON
  return validateOutput(guardedSchema, response.text);
}

// Demo run
async function main() {
  const result = await guardedAgent("Explain AI in one line.");
  console.log("Validated Output:\n", result);
}

await main();
```

---

# **5. Output Example**

```
Validated Output:
{
  answer: "AI is a field of computer science that enables machines to learn and make decisions.",
  info: {}
}
```

Fully validated JSON, safe to use everywhere.

---

# **6. Why This Is Important**

Without guards:

* Agent can hallucinate fields
* JSON may break your application
* A user can crash the model with bad input
* Your tools can be invoked incorrectly

With guards:

* Predictable
* Safe
* Developer-friendly
* Production-ready

---

# **7. Notes for your Topics folder**

Create:

```
üìÅTopic 6 Guards & Observability
 ‚îú‚îÄ‚îÄ 01.guards-input-output.md
```

Content:

```
# Topic 6 ‚Äî Guards, Validation & Observability

Input Guards:
- Validate user input before sending to model
- Avoid unsafe or malicious strings
- Limit length and enforce format

Output Guards:
- Validate model JSON using Zod
- Prevent hallucinated fields
- Enforce strict schema

Observability:
- Log tokens, tool calls, latency
- Use console/debug logs during development
- In production use logging systems (pino/winston)

Purpose:
Ensure agent reliability, safety, and predictability.
```

---
