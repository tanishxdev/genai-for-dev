# **Topic 2.2 – Structured Outputs (JSON Schema in Gemini SDK)**

* Followed: 
    * https://ai.google.dev/gemini-api/docs/structured-output?example=recipe

---

## **1. Concept**

By default, when you call Gemini:

```js
ai.models.generateContent({ ... })
```

you get **free-form text** — natural language, variable format, sometimes inconsistent.

But in real-world applications (like agents, dashboards, APIs), you often need **structured data**.

**Structured Output** = Force Gemini to return a **valid JSON object** following your defined schema.

This ensures:

* Predictable, parsable output
* Type-safety and easier programmatic handling
* Ideal for agents that call external tools or APIs

---

## **2. How it works**

You provide:

1. A **prompt** (as usual)
2. A **JSON Schema** that defines structure (using Zod or plain JSON)
3. `responseMimeType: "application/json"`
4. `responseJsonSchema: schema`

Then Gemini generates **valid JSON output** that conforms to that schema.

---

## **3. Example Use Case**

Suppose you want to extract structured information from user text:

> “Elon Musk founded SpaceX in 2002 in California.”

You want Gemini to output this as structured JSON:

```json
{
  "person": "Elon Musk",
  "company": "SpaceX",
  "founded_year": 2002,
  "location": "California"
}
```

---

## **4. Code Example**

**File:** `src/03.structured-output.js`

```js
// -------------------------------------------------------------
// GOAL: Demonstrate Structured Output using Gemini SDK
// -------------------------------------------------------------
// Concepts:
// - Define schema using Zod
// - Convert it to JSON Schema via zod-to-json-schema
// - Force Gemini to respond in valid JSON format
// -------------------------------------------------------------

import ai from "../utils/geminiClient.js";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

// 1️⃣ Define the data structure you want
const infoSchema = z.object({
  person: z.string().describe("The name of the person mentioned."),
  company: z.string().describe("The company they are associated with."),
  founded_year: z.number().describe("Year the company was founded."),
  location: z.string().describe("Where the company was founded.")
});

// 2️⃣ Write the natural language text to extract data from
const prompt = `
Elon Musk founded SpaceX in 2002 in California.
`;

// 3️⃣ Ask Gemini for structured output following your schema
async function main() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: prompt,
    config: {
      responseMimeType: "application/json",
      responseJsonSchema: zodToJsonSchema(infoSchema),
    },
  });

  // 4️⃣ Parse and validate the model’s JSON output
  const result = infoSchema.parse(JSON.parse(response.text));

  console.log("Structured Output:\n");
  console.log(result);
}

await main();
```

---

### **Expected Output**

```
Structured Output:

{
  person: 'Elon Musk',
  company: 'SpaceX',
  founded_year: 2002,
  location: 'California'
}
```

---

## **5. Deep Explanation**

### **Zod Schema**

Zod lets you define structured data **like TypeScript types**, with validation and descriptions:

```js
const schema = z.object({
  key: z.string().describe("Description of this key")
});
```

### **Conversion**

`zodToJsonSchema(schema)` converts Zod schema into a **standard JSON Schema** format that Gemini understands.

### **Gemini Configuration**

```js
config: {
  responseMimeType: "application/json",
  responseJsonSchema: zodToJsonSchema(infoSchema)
}
```

* Tells Gemini to respond strictly as JSON.
* Gemini validates its own output to match this schema before returning.

---

## **6. Common Use Cases**

| Category              | Example                                        |
| --------------------- | ---------------------------------------------- |
| Data extraction       | Extract person, date, product from text        |
| Classification        | Sentiment analysis (positive/negative/neutral) |
| Agent workflows       | Generate API payloads or form data             |
| JSON output pipelines | Connect LLMs with databases or scripts         |

---

## **7. Error Handling Tip**

If Gemini fails schema validation (rare but possible):

* You’ll get an exception from `.parse()`.
* Wrap parsing in `try...catch` block.

Example:

```js
try {
  const result = infoSchema.parse(JSON.parse(response.text));
  console.log(result);
} catch (err) {
  console.error("Validation Error:", err.errors);
}
```

---

## **8. Notes for `/Topics OR Concepts/topic2/`**

**File:** `02.structured-output.md`

```
# Topic 2.2: Structured Output (Gemini SDK)

- Structured output forces Gemini to return JSON that matches your defined schema.
- Useful for data extraction, classification, and API workflows.
- Requires:
  1. responseMimeType: "application/json"
  2. responseJsonSchema: schema

- In JS SDK:
  Use Zod + zod-to-json-schema to define schema easily.
- Always validate final JSON using schema.parse().

Example:
{
  "name": "John Doe",
  "age": 28,
  "city": "New York"
}
```

---


> **Why that Zod error happened, and how the fixed version solves it.**

---

## **1. What actually happened (Root Cause)**

When you ran this line:

```js
infoSchema.parse(response.json);
```

The error said:

```
expected object, received undefined
```

That means:
`response.json` was `undefined` → i.e. there was **no actual JSON** in that variable.

---

### **But why was `response.json` undefined?**

Because the Gemini SDK **does not** give the model’s answer in a `json` property.
Instead, it usually returns output like this:

```js
response.output[0].content[0].text
```

So the structure looks like:

```
{
  output: [
    {
      content: [
        { text: "{ \"person\": \"Elon Musk\", ... }" }
      ]
    }
  ]
}
```

But your code tried to read `response.json`, which doesn’t exist.
So it became `undefined`.

Then you passed `undefined` into:

```js
infoSchema.parse(undefined)
```

And Zod said:

> “Hey! I was expecting an object (like `{ person: ..., company: ... }`),
> but you gave me undefined.”

Hence the **ZodError**.

---

## **2. How we fixed it**

We changed this:

```js
infoSchema.parse(response.json);
```

To this:

```js
const raw =
  response.output?.[0]?.content?.[0]?.text ||
  response.output?.[0]?.content?.[0]?.json ||
  response.text ||
  "{}";

const jsonData = JSON.parse(raw);
const result = infoSchema.parse(jsonData);
```

### **Step-by-step meaning:**

1. `response.output?.[0]?.content?.[0]?.text`
   → safely tries to access the text output (where Gemini actually returns the response).

2. `||` (OR operator)
   → means “if this is missing, try the next option.”

3. `JSON.parse(raw)`
   → converts the JSON **string** into a real JS object.

4. `infoSchema.parse(jsonData)`
   → now Zod gets a valid object — and validation works fine.

---

## **3. Why this approach is better**

| Problem (Before)                    | Solution (Now)                            |
| ----------------------------------- | ----------------------------------------- |
| Used wrong property `response.json` | Used actual Gemini response structure     |
| Didn’t convert text → JSON          | Added `JSON.parse(raw)`                   |
| No safety for missing fields        | Used optional chaining `?.` and fallbacks |
| Zod got `undefined`                 | Zod now gets a valid object               |

---

## **In Short**

* **Error cause:** You were reading the wrong property (`response.json`).
* **Zod complained:** Because it got `undefined` instead of an object.
* **Solution:** Extract correct text → parse to JSON → then validate with Zod.






# Debug 

> **Why that Zod error happened, and how the fixed version solves it.**

---

## **1. What actually happened (Root Cause)**

When you ran this line:

```js
infoSchema.parse(response.json);
```

The error said:

```
expected object, received undefined
```

That means:
`response.json` was `undefined` → i.e. there was **no actual JSON** in that variable.

---

### **But why was `response.json` undefined?**

Because the Gemini SDK **does not** give the model’s answer in a `json` property.
Instead, it usually returns output like this:

```js
response.output[0].content[0].text
```

So the structure looks like:

```
{
  output: [
    {
      content: [
        { text: "{ \"person\": \"Elon Musk\", ... }" }
      ]
    }
  ]
}
```

But your code tried to read `response.json`, which doesn’t exist.
So it became `undefined`.

Then you passed `undefined` into:

```js
infoSchema.parse(undefined)
```

And Zod said:

> “Hey! I was expecting an object (like `{ person: ..., company: ... }`),
> but you gave me undefined.”

Hence the **ZodError**.

---

## **2. How we fixed it**

We changed this:

```js
infoSchema.parse(response.json);
```

To this:

```js
const raw =
  response.output?.[0]?.content?.[0]?.text ||
  response.output?.[0]?.content?.[0]?.json ||
  response.text ||
  "{}";

const jsonData = JSON.parse(raw);
const result = infoSchema.parse(jsonData);
```

### **Step-by-step meaning:**

1. `response.output?.[0]?.content?.[0]?.text`
   → safely tries to access the text output (where Gemini actually returns the response).

2. `||` (OR operator)
   → means “if this is missing, try the next option.”

3. `JSON.parse(raw)`
   → converts the JSON **string** into a real JS object.

4. `infoSchema.parse(jsonData)`
   → now Zod gets a valid object — and validation works fine.

---

## **3. Why this approach is better**

| Problem (Before)                    | Solution (Now)                            |
| ----------------------------------- | ----------------------------------------- |
| Used wrong property `response.json` | Used actual Gemini response structure     |
| Didn’t convert text → JSON          | Added `JSON.parse(raw)`                   |
| No safety for missing fields        | Used optional chaining `?.` and fallbacks |
| Zod got `undefined`                 | Zod now gets a valid object               |

---

## **In Short**

* **Error cause:** You were reading the wrong property (`response.json`).
* **Zod complained:** Because it got `undefined` instead of an object.
* **Solution:** Extract correct text → parse to JSON → then validate with Zod.

---
